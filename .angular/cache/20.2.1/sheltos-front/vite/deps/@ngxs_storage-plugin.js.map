{
  "version": 3,
  "sources": ["../../../../../../node_modules/@ngxs/storage-plugin/fesm2022/ngxs-storage-plugin-internals.mjs", "../../../../../../node_modules/@ngxs/storage-plugin/fesm2022/ngxs-storage-plugin.mjs"],
  "sourcesContent": ["import { InjectionToken, inject } from '@angular/core';\nimport { StateToken } from '@ngxs/store';\nimport { ɵhasOwnProperty as _hasOwnProperty, ɵMETA_OPTIONS_KEY as _META_OPTIONS_KEY } from '@ngxs/store/internals';\n\n/**\n * The following key is used to store the entire serialized\n * state when no specific state is provided.\n */\nconst ɵDEFAULT_STATE_KEY = '@@STATE';\nvar StorageOption;\n(function (StorageOption) {\n    StorageOption[StorageOption[\"LocalStorage\"] = 0] = \"LocalStorage\";\n    StorageOption[StorageOption[\"SessionStorage\"] = 1] = \"SessionStorage\";\n})(StorageOption || (StorageOption = {}));\nconst ɵUSER_OPTIONS = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'USER_OPTIONS' : '');\n// Determines whether all states in the NGXS registry should be persisted or not.\nconst ɵALL_STATES_PERSISTED = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ALL_STATES_PERSISTED' : '', {\n    providedIn: 'root',\n    factory: () => inject(ɵUSER_OPTIONS).keys === '*'\n});\nconst ɵNGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_STORAGE_PLUGIN_OPTIONS' : '');\nconst STORAGE_ENGINE = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'STORAGE_ENGINE' : '');\n\n/** Determines whether the provided key has the following structure. */\nfunction ɵisKeyWithExplicitEngine(key) {\n    return !!key?.engine;\n}\nfunction ɵextractStringKey(storageKey) {\n    // Extract the actual key out of the `{ key, engine }` structure.\n    if (ɵisKeyWithExplicitEngine(storageKey)) {\n        storageKey = storageKey.key;\n    }\n    // Given the `storageKey` is a class, for instance, `AuthState`.\n    // We should retrieve its metadata and the `name` property.\n    // The `name` property might be a string (state name) or a state token.\n    if (_hasOwnProperty(storageKey, _META_OPTIONS_KEY)) {\n        storageKey = storageKey[_META_OPTIONS_KEY].name;\n    }\n    return storageKey instanceof StateToken ? storageKey.getName() : storageKey;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { STORAGE_ENGINE, StorageOption, ɵALL_STATES_PERSISTED, ɵDEFAULT_STATE_KEY, ɵNGXS_STORAGE_PLUGIN_OPTIONS, ɵUSER_OPTIONS, ɵextractStringKey, ɵisKeyWithExplicitEngine };\n\n", "import * as i0 from '@angular/core';\nimport { inject, Injector, Injectable, NgModule, makeEnvironmentProviders, provideEnvironmentInitializer, InjectionToken } from '@angular/core';\nimport { withNgxsPlugin } from '@ngxs/store';\nimport { ɵDEFAULT_STATE_KEY as _DEFAULT_STATE_KEY, StorageOption, ɵNGXS_STORAGE_PLUGIN_OPTIONS as _NGXS_STORAGE_PLUGIN_OPTIONS, ɵextractStringKey as _extractStringKey, ɵisKeyWithExplicitEngine as _isKeyWithExplicitEngine, STORAGE_ENGINE, ɵALL_STATES_PERSISTED as _ALL_STATES_PERSISTED, ɵUSER_OPTIONS as _USER_OPTIONS } from '@ngxs/storage-plugin/internals';\nexport { STORAGE_ENGINE, StorageOption } from '@ngxs/storage-plugin/internals';\nimport { ɵhasOwnProperty as _hasOwnProperty } from '@ngxs/store/internals';\nimport { actionMatcher, InitState, UpdateState, getValue, setValue } from '@ngxs/store/plugins';\nimport { tap } from 'rxjs';\nfunction storageOptionsFactory(options) {\n  return {\n    storage: StorageOption.LocalStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    beforeSerialize: obj => obj,\n    afterDeserialize: obj => obj,\n    ...options,\n    keys: options.keys === '*' ? [_DEFAULT_STATE_KEY] : options.keys\n  };\n}\nfunction engineFactory(options) {\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    return null;\n  }\n  if (options.storage === StorageOption.LocalStorage) {\n    return localStorage;\n  } else if (options.storage === StorageOption.SessionStorage) {\n    return sessionStorage;\n  }\n  return null;\n}\nfunction getStorageKey(key, options) {\n  // Prepends the `namespace` option to any key if it's been provided by a user.\n  // So `@@STATE` becomes `my-app:@@STATE`.\n  return options?.namespace ? `${options.namespace}:${key}` : key;\n}\nclass ɵNgxsStoragePluginKeysManager {\n  /** Store keys separately in a set so we're able to check if the key already exists. */\n  _keys = new Set();\n  _injector = inject(Injector);\n  _keysWithEngines = [];\n  constructor() {\n    const {\n      keys\n    } = inject(_NGXS_STORAGE_PLUGIN_OPTIONS);\n    this.addKeys(keys);\n  }\n  getKeysWithEngines() {\n    // Spread to prevent external code from directly modifying the internal state.\n    return [...this._keysWithEngines];\n  }\n  addKeys(storageKeys) {\n    for (const storageKey of storageKeys) {\n      const key = _extractStringKey(storageKey);\n      // The user may call `withStorageFeature` with the same state multiple times.\n      // Let's prevent duplicating state names in the `keysWithEngines` list.\n      // Please note that calling provideStates multiple times with the same state is\n      // acceptable behavior. This may occur because the state could be necessary at the\n      // feature level, and different parts of the application might require its registration.\n      // Consequently, `withStorageFeature` may also be called multiple times.\n      if (this._keys.has(key)) {\n        continue;\n      }\n      this._keys.add(key);\n      const engine = _isKeyWithExplicitEngine(storageKey) ? this._injector.get(storageKey.engine) : this._injector.get(STORAGE_ENGINE);\n      this._keysWithEngines.push({\n        key,\n        engine\n      });\n    }\n  }\n  /** @nocollapse */\n  static ɵfac = function ɵNgxsStoragePluginKeysManager_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || ɵNgxsStoragePluginKeysManager)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ɵNgxsStoragePluginKeysManager,\n    factory: ɵNgxsStoragePluginKeysManager.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ɵNgxsStoragePluginKeysManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\nclass NgxsStoragePlugin {\n  _keysManager = inject(ɵNgxsStoragePluginKeysManager);\n  _options = inject(_NGXS_STORAGE_PLUGIN_OPTIONS);\n  _allStatesPersisted = inject(_ALL_STATES_PERSISTED);\n  handle(state, event, next) {\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n      return next(state, event);\n    }\n    const matches = actionMatcher(event);\n    const isInitAction = matches(InitState);\n    const isUpdateAction = matches(UpdateState);\n    const isInitOrUpdateAction = isInitAction || isUpdateAction;\n    let hasMigration = false;\n    if (isInitOrUpdateAction) {\n      const addedStates = isUpdateAction && event.addedStates;\n      for (const {\n        key,\n        engine\n      } of this._keysManager.getKeysWithEngines()) {\n        // We're checking what states have been added by NGXS and if any of these states should be handled by\n        // the storage plugin. For instance, we only want to deserialize the `auth` state, NGXS has added\n        // the `user` state, the storage plugin will be rerun and will do redundant deserialization.\n        // `usesDefaultStateKey` is necessary to check since `event.addedStates` never contains `@@STATE`.\n        if (!this._allStatesPersisted && addedStates) {\n          // We support providing keys that can be deeply nested via dot notation, for instance,\n          // `keys: ['myState.myProperty']` is a valid key.\n          // The state name should always go first. The below code checks if the `key` includes dot\n          // notation and extracts the state name out of the key.\n          // Given the `key` is `myState.myProperty`, the `addedStates` will only contain `myState`.\n          const dotNotationIndex = key.indexOf(DOT);\n          const stateName = dotNotationIndex > -1 ? key.slice(0, dotNotationIndex) : key;\n          if (!_hasOwnProperty(addedStates, stateName)) continue;\n        }\n        const storageKey = getStorageKey(key, this._options);\n        let storedValue = engine.getItem(storageKey);\n        if (storedValue !== 'undefined' && storedValue != null) {\n          try {\n            const newVal = this._options.deserialize(storedValue);\n            storedValue = this._options.afterDeserialize(newVal, key);\n          } catch {\n            typeof ngDevMode !== 'undefined' && ngDevMode && console.error(`Error ocurred while deserializing the ${storageKey} store value, falling back to empty object, the value obtained from the store: `, storedValue);\n            storedValue = {};\n          }\n          this._options.migrations?.forEach(strategy => {\n            const versionMatch = strategy.version === getValue(storedValue, strategy.versionKey || 'version');\n            const keyMatch = !strategy.key && this._allStatesPersisted || strategy.key === key;\n            if (versionMatch && keyMatch) {\n              storedValue = strategy.migrate(storedValue);\n              hasMigration = true;\n            }\n          });\n          if (this._allStatesPersisted) {\n            storedValue = this._hydrateSelectivelyOnUpdate(storedValue, addedStates);\n            state = {\n              ...state,\n              ...storedValue\n            };\n          } else {\n            state = setValue(state, key, storedValue);\n          }\n        }\n      }\n    }\n    return next(state, event).pipe(tap(nextState => {\n      if (isInitOrUpdateAction && !hasMigration) {\n        return;\n      }\n      for (const {\n        key,\n        engine\n      } of this._keysManager.getKeysWithEngines()) {\n        let storedValue = nextState;\n        const storageKey = getStorageKey(key, this._options);\n        if (key !== _DEFAULT_STATE_KEY) {\n          storedValue = getValue(nextState, key);\n        }\n        try {\n          const newStoredValue = this._options.beforeSerialize(storedValue, key);\n          engine.setItem(storageKey, this._options.serialize(newStoredValue));\n        } catch (error) {\n          if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n            if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {\n              console.error(`The ${storageKey} store value exceeds the browser storage quota: `, storedValue);\n            } else {\n              console.error(`Error ocurred while serializing the ${storageKey} store value, value not updated, the value obtained from the store: `, storedValue);\n            }\n          }\n        }\n      }\n    }));\n  }\n  _hydrateSelectivelyOnUpdate(storedValue, addedStates) {\n    // The `UpdateState` action is triggered whenever a feature state is added.\n    // The condition below is only satisfied when this action is triggered.\n    // Let's consider two states: `counter` and `@ngxs/router-plugin` state.\n    // When `provideStore` is called, `CounterState` is provided at the root level,\n    // while `@ngxs/router-plugin` is provided as a feature state. Previously, the storage\n    // plugin might have stored the value of the counter state as `10`. If `CounterState`\n    // implements the `ngxsOnInit` hook and sets the state to `999`, the storage plugin will\n    // reset the entire state when the `RouterState` is registered.\n    // Consequently, the `counter` state will revert back to `10` instead of `999`.\n    if (!storedValue || !addedStates || Object.keys(addedStates).length === 0) {\n      // Nothing to update if `addedStates` object is empty.\n      return storedValue;\n    }\n    // The `storedValue` can be the entire state when the default state key\n    // is used. However, if `addedStates` only contains the `router` value,\n    // we only want to merge the state with that `router` value.\n    // Given the `storedValue` is an object:\n    // `{ counter: 10, router: {...} }`\n    // This will only select the `router` object from the `storedValue`,\n    // avoiding unnecessary rehydration of the `counter` state.\n    return Object.keys(addedStates).reduce((accumulator, addedState) => {\n      if (_hasOwnProperty(storedValue, addedState)) {\n        accumulator[addedState] = storedValue[addedState];\n      }\n      return accumulator;\n    }, {});\n  }\n  /** @nocollapse */\n  static ɵfac = function NgxsStoragePlugin_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxsStoragePlugin)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxsStoragePlugin,\n    factory: NgxsStoragePlugin.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsStoragePlugin, [{\n    type: Injectable\n  }], null, null);\n})();\nconst DOT = '.';\nclass NgxsStoragePluginModule {\n  static forRoot(options) {\n    return {\n      ngModule: NgxsStoragePluginModule,\n      providers: [withNgxsPlugin(NgxsStoragePlugin), {\n        provide: _USER_OPTIONS,\n        useValue: options\n      }, {\n        provide: _NGXS_STORAGE_PLUGIN_OPTIONS,\n        useFactory: storageOptionsFactory,\n        deps: [_USER_OPTIONS]\n      }, {\n        provide: STORAGE_ENGINE,\n        useFactory: engineFactory,\n        deps: [_NGXS_STORAGE_PLUGIN_OPTIONS]\n      }]\n    };\n  }\n  /** @nocollapse */\n  static ɵfac = function NgxsStoragePluginModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxsStoragePluginModule)();\n  };\n  /** @nocollapse */\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsStoragePluginModule\n  });\n  /** @nocollapse */\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsStoragePluginModule, [{\n    type: NgModule\n  }], null, null);\n})();\nfunction withNgxsStoragePlugin(options) {\n  return makeEnvironmentProviders([withNgxsPlugin(NgxsStoragePlugin), {\n    provide: _USER_OPTIONS,\n    useValue: options\n  }, {\n    provide: _NGXS_STORAGE_PLUGIN_OPTIONS,\n    useFactory: storageOptionsFactory,\n    deps: [_USER_OPTIONS]\n  }, {\n    provide: STORAGE_ENGINE,\n    useFactory: engineFactory,\n    deps: [_NGXS_STORAGE_PLUGIN_OPTIONS]\n  }]);\n}\nfunction withStorageFeature(storageKeys) {\n  return provideEnvironmentInitializer(() => {\n    const allStatesPersisted = inject(_ALL_STATES_PERSISTED);\n    if (allStatesPersisted) {\n      if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const message = 'The NGXS storage plugin is currently persisting all states because the `keys` ' + 'option was explicitly set to `*` at the root level. To selectively persist states, ' + 'consider explicitly specifying them, allowing for addition at the feature level.';\n        console.error(message);\n      }\n      // We should prevent the addition of any feature states to persistence\n      // if the `keys` property is set to `*`, as this could disrupt the algorithm\n      // used in the storage plugin. Instead, we should log an error in development\n      // mode. In production, it should continue to function, but act as a no-op.\n      return;\n    }\n    inject(ɵNgxsStoragePluginKeysManager).addKeys(storageKeys);\n  });\n}\nconst LOCAL_STORAGE_ENGINE = /* @__PURE__ */new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'LOCAL_STORAGE_ENGINE' : '', {\n  providedIn: 'root',\n  factory: () => typeof ngServerMode !== 'undefined' && ngServerMode ? null : localStorage\n});\nconst SESSION_STORAGE_ENGINE = /* @__PURE__ */new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'SESSION_STORAGE_ENGINE' : '', {\n  providedIn: 'root',\n  factory: () => typeof ngServerMode !== 'undefined' && ngServerMode ? null : sessionStorage\n});\n\n/**\n * The public api for consumers of @ngxs/storage-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LOCAL_STORAGE_ENGINE, NgxsStoragePlugin, NgxsStoragePluginModule, SESSION_STORAGE_ENGINE, withNgxsStoragePlugin, withStorageFeature };\n"],
  "mappings": "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",
  "names": ["StorageOption"]
}
